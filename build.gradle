class ProjectVersionPlugin implements Plugin<Project> {
    void apply(Project project) {
        project.extensions.create('projectVersion', ProjectVersionPluginExtension, project)
    }
}

abstract class ProjectVersion {
    protected abstract String getVersion()

    @Override
    String toString() {
        getVersion()
    }
}

interface ProjectVersionResolver {
    ProjectVersion currentVersion()
}

class FixedVersion extends ProjectVersion {
    private static final ProjectVersion DEFAULT_VERSION = fixed('0.1.0')

    final String version

    private FixedVersion(String version) {
        this.version = version
    }

    static ProjectVersion fixed(String version) {
        new FixedVersion(Objects.requireNonNull(version))
    }

    static ProjectVersion defaultVersion() {
        DEFAULT_VERSION
    }
}

class SemanticVersion extends ProjectVersion {
    private final int major
    private final int minor
    private final int patch
    private final boolean released

    private SemanticVersion(int major, int minor, int patch, boolean released) {
        this.major = major
        this.minor = minor
        this.patch = patch
        this.released = released
    }

    static SemanticVersion semantic(int major, int minor, int patch, boolean released) {
        new SemanticVersion(major, minor, patch, released)
    }

    static SemanticVersion semantic(String version,
                                    String prefix = '') {
        def versionParts = trimPrefix(version, prefix).tokenize(".")
        new SemanticVersion(
                Integer.valueOf(versionParts[0]),
                Integer.valueOf(versionParts[1]),
                Integer.valueOf(versionParts[2]),
                true)
    }

    private static String trimPrefix(String str, String prefix) {
        str.substring(prefix.length())
    }

    SemanticVersion withMinimumMajor(int minMajor) {
        minMajor > major ?
                new SemanticVersion(minMajor, 0, 0, false) :
                this
    }

    SemanticVersion nextMinor() {
        new SemanticVersion(major, minor + 1, 0, false)
    }

    SemanticVersion nextPatch() {
        new SemanticVersion(major, minor, patch + 1, false)
    }

    SemanticVersion withReleased(boolean status) {
        released == status ? this : new SemanticVersion(major, minor, patch, status)
    }

    String withPrefix(String prefix) {
        prefix + toString()
    }

    @Override
    protected String getVersion() {
        released ? "$major.$minor.$patch" : "$major.$minor.$patch-SNAPSHOT"
    }

    boolean equals(o) {
        if (this.is(o)) return true
        if (getClass() != o.class) return false

        SemanticVersion that = (SemanticVersion) o

        if (major != that.major) return false
        if (minor != that.minor) return false
        if (patch != that.patch) return false

        return true
    }

    int hashCode() {
        int result
        result = major
        result = 31 * result + minor
        result = 31 * result + patch
        return result
    }
}

class GitProjectVersionResolver implements ProjectVersionResolver {

    public static final VERSION_PREFIX = "v"

    private final File vcsRoot
    private final String defaultBranch
    private final int majorVersion

    private GitProjectVersionResolver(File vcsRoot, String defaultBranch, int majorVersion) {
        this.vcsRoot = vcsRoot
        this.defaultBranch = defaultBranch
        this.majorVersion = majorVersion
    }

    static GitProjectVersionResolver gitProjectVersionResolver(File vcsRoot,
                                                               int majorVersion = 0,
                                                               String defaultBranch = 'master') {
        new GitProjectVersionResolver(vcsRoot, defaultBranch, majorVersion)
    }

    static String createTag(String version, File vcsRoot) {
        def descriptionParts = describeCommit(vcsRoot)
        if (isUntaggedOrDirty(descriptionParts)) {
            if (isDirty(descriptionParts)) {
                throw new IllegalStateException('Workspace is not clean. Please commit your changes first.')
            }
            return "git tag ${VERSION_PREFIX}${version}".execute([], vcsRoot).text.trim()
        }
        return "tag already exists"
    }

    static String currentCommitId(File vcsRoot) {
        return "git rev-parse HEAD".execute([], vcsRoot).text.trim()
    }

    static String currentBranch(File vcsRoot) {
        return "git rev-parse --abbrev-ref HEAD".execute([], vcsRoot).text.trim()
    }

    @Override
    ProjectVersion currentVersion() {
        nextVersion()
    }

    private SemanticVersion nextVersion() {
        List<String> descriptionParts = describeCommit(vcsRoot)
        def currentVersion = SemanticVersion.semantic(descriptionParts[0], VERSION_PREFIX)

        // only increment version number if changes are present to last tagged commit
        return isUntaggedOrDirty(descriptionParts) ?
                incrementVersion(currentVersion, !defaultBranch.equals(currentBranch(vcsRoot)), majorVersion)
                .withReleased(!isDirty(descriptionParts)) :
                currentVersion
    }

    private static List<String> describeCommit(File vcsRoot) {
        // git describe yields something like v0.1.0-1-g768be9d
        def description = "git describe --tags --match ${VERSION_PREFIX}* --dirty".execute([], vcsRoot).text.trim()
        // initialize to v0.0.0-whoKnows if no tag yet
        return description.length() == 0 ?
                ["${VERSION_PREFIX}0.0.0", "dirty"] :
                description.tokenize("-")
    }
    
    private static boolean isUntaggedOrDirty(List<String> descriptionParts) {
        return descriptionParts.size() > 1
    }

    private static boolean isDirty(List<String> descriptionParts) {
        return descriptionParts[descriptionParts.size() - 1] == 'dirty'
    }

    private static SemanticVersion incrementVersion(SemanticVersion currentVersion, boolean isPatch, int majorVersion) {
        isPatch
                ? currentVersion.nextPatch()
                : currentVersion.nextMinor().withMinimumMajor(nextMajor(majorVersion))
    }

    private static int nextMajor(int majorVersion) {
        majorVersion < 0 ? 0 : majorVersion
        //majorVersion < 0 ? sprintNumber(Instant.now()) : majorVersion
    }
    
//    private static sprintNumber(Instant day) {
//    }
}

class ProjectVersionPluginExtension {
    private final Project project
    final Property<ProjectVersion> version

    ProjectVersionPluginExtension(Project project) {
        this.project = project
        version = project.objects.property(ProjectVersion)
    }

    ProjectVersion getVersion() {
        version.getOrElse(FixedVersion.defaultVersion())
    }

    void setVersion(String version) {
        this.version.set(FixedVersion.fixed(version))
        apply()
    }

    void setVersion(ProjectVersionResolver resolver) {
        this.version.set(resolver.currentVersion())
        apply()
    }

    private void apply() {
        project.version = getVersion()
    }
}

apply plugin: ProjectVersionPlugin

projectVersion {
    version = GitProjectVersionResolver.gitProjectVersionResolver(project.projectDir)
}

tasks.create('testVersion') {
    doLast {
        println "The project's name    : ${project.name}"
        println "The project's version : ${project.version}"
    }
}
