class ProjectVersionPlugin implements Plugin<Project> {
    void apply(Project project) {
        project.extensions.create('projectVersion', ProjectVersionPluginExtension, project)
    }
}

abstract class ProjectVersion {
    protected abstract String getVersion()

    @Override
    String toString() {
        getVersion()
    }
}

interface ProjectVersionResolver {
    ProjectVersion currentVersion()
}

class FixedVersion extends ProjectVersion {
    private static final ProjectVersion DEFAULT_VERSION = fixed('0.1.0')

    final String version

    private FixedVersion(String version) {
        this.version = version
    }

    static ProjectVersion fixed(String version) {
        new FixedVersion(Objects.requireNonNull(version))
    }

    static ProjectVersion defaultVersion() {
        DEFAULT_VERSION
    }
}

class SemanticVersion extends ProjectVersion {
    private final int major
    private final int minor
    private final int patch
    private final boolean released

    private SemanticVersion(int major, int minor, int patch, boolean released) {
        this.major = major
        this.minor = minor
        this.patch = patch
        this.released = released
    }

    static SemanticVersion semantic(int major, int minor, int patch, boolean released) {
        new SemanticVersion(major, minor, patch, released)
    }

    static SemanticVersion semantic(String version) {
        def versionParts = version.tokenize(".")
        new SemanticVersion(
                Integer.valueOf(versionParts[0]),
                Integer.valueOf(versionParts[1]),
                Integer.valueOf(versionParts[2]),
                true)
    }

    SemanticVersion withMinimumMajor(int minMajor) {
        minMajor > major ?
                new SemanticVersion(minMajor, 0, 0, false) :
                this
    }

    SemanticVersion nextMinor() {
        new SemanticVersion(major, minor + 1, 0, false)
    }

    SemanticVersion nextPatch() {
        new SemanticVersion(major, minor, patch + 1, false)
    }

    SemanticVersion withReleased(boolean status) {
        released == status ? this : new SemanticVersion(major, minor, patch, status)
    }

    @Override
    protected String getVersion() {
        released ? "$major.$minor.$patch" : "$major.$minor.$patch-SNAPSHOT"
    }

    boolean equals(o) {
        if (this.is(o)) return true
        if (getClass() != o.class) return false

        SemanticVersion that = (SemanticVersion) o

        if (major != that.major) return false
        if (minor != that.minor) return false
        if (patch != that.patch) return false

        return true
    }

    int hashCode() {
        int result
        result = major
        result = 31 * result + minor
        result = 31 * result + patch
        return result
    }
}

interface VersioningStrategy<T extends ProjectVersion> {
    T nextVersion(T oldVersion)
}

interface GitTagParser<T extends ProjectVersion> {
    T parseAsVersion(String versionString)
}

class SemanticVersioningStrategies {

    static VersioningStrategy<SemanticVersion> defaultStrategy(int major, boolean isPatch) {
        new VersioningStrategy<SemanticVersion>() {
            @Override
            SemanticVersion nextVersion(SemanticVersion oldVersion) {
                isPatch
                        ? oldVersion.nextPatch()
                        : oldVersion.nextMinor().withMinimumMajor(major)
            }

        }
    }
}

class GitProjectVersionResolver<T extends ProjectVersion> implements ProjectVersionResolver {

    public static final VERSION_PREFIX = "v"

    private final File vcsRoot
    private final GitTagParser<T> gitTagParser
    private final VersioningStrategy<T> strategy

    private GitProjectVersionResolver(File vcsRoot,
                                      GitTagParser<T> gitTagParser,
                                      VersioningStrategy<T> strategy) {
        this.vcsRoot = vcsRoot
        this.gitTagParser = gitTagParser
        this.strategy = strategy
    }

    static GitProjectVersionResolver gitProjectVersionResolver(File vcsRoot,
                                                               int majorVersion = 0,
                                                               String defaultBranch = 'master') {
        new GitProjectVersionResolver(vcsRoot,
                { String versionString ->
                    SemanticVersion.semantic(versionString)
                },
                SemanticVersioningStrategies.defaultStrategy(majorVersion, !defaultBranch.equals(currentBranch(vcsRoot)))
        )
    }

    static <T extends ProjectVersion> GitProjectVersionResolver<T> gitProjectVersionResolver(
            File vcsRoot,
            GitTagParser<T> gitTagParser,
            VersioningStrategy<T> strategy) {
        new GitProjectVersionResolver<>(vcsRoot,
                requireNonNull(gitTagParser),
                requireNonNull(strategy))
    }

    static String createTag(String version, File vcsRoot) {
        def descriptionParts = describeCommit(vcsRoot)
        if (isUntaggedOrDirty(descriptionParts)) {
            if (isDirty(descriptionParts)) {
                throw new IllegalStateException('Workspace is not clean. Please commit your changes first.')
            }
            return "git tag ${VERSION_PREFIX}${version}".execute([], vcsRoot).text.trim()
        }
        return "tag already exists"
    }

    static String currentCommitId(File vcsRoot) {
        return "git rev-parse HEAD".execute([], vcsRoot).text.trim()
    }

    static String currentBranch(File vcsRoot) {
        return "git rev-parse --abbrev-ref HEAD".execute([], vcsRoot).text.trim()
    }

    @Override
    T currentVersion() {
        List<String> descriptionParts = describeCommit(vcsRoot)
        def currentVersion = gitTagParser.parseAsVersion(descriptionParts[0])

        // only increment version number if changes are present to last tagged commit
        isUntaggedOrDirty(descriptionParts) ?
                strategy.nextVersion(currentVersion)
                        .withReleased(!isDirty(descriptionParts)) :
                currentVersion
    }

    private static List<String> describeCommit(File vcsRoot) {
        // git describe yields something like v0.1.0-1-g768be9d
        def description = "git describe --tags --match ${VERSION_PREFIX}* --dirty".execute([], vcsRoot).text.trim()
        // initialize to v0.0.0-whoKnows if no tag yet
        return description.length() == 0 ?
                ["0.0.0", "dirty"] :
                trimPrefix(description, VERSION_PREFIX).tokenize("-")
    }


    private static String trimPrefix(String str, String prefix) {
        str.substring(prefix.length())
    }

    private static boolean isUntaggedOrDirty(List<String> descriptionParts) {
        return descriptionParts.size() > 1
    }

    private static boolean isDirty(List<String> descriptionParts) {
        return descriptionParts[descriptionParts.size() - 1] == 'dirty'
    }

//    private static sprintNumber(Instant day) {
//    }
}

class ProjectVersionPluginExtension {
    private final Project project
    final Property<ProjectVersion> version

    ProjectVersionPluginExtension(Project project) {
        this.project = project
        version = project.objects.property(ProjectVersion)
    }

    ProjectVersion getVersion() {
        version.getOrElse(FixedVersion.defaultVersion())
    }

    void setVersion(String version) {
        this.version.set(FixedVersion.fixed(version))
        apply()
    }

    void setVersion(ProjectVersionResolver resolver) {
        this.version.set(resolver.currentVersion())
        apply()
    }

    void deriveFromGitTag() {
        setVersion(GitProjectVersionResolver.gitProjectVersionResolver(project.projectDir))
    }

    private void apply() {
        project.version = getVersion()
    }
}

apply plugin: ProjectVersionPlugin

projectVersion {
    deriveFromGitTag()
}

tasks.create('testVersion') {
    doLast {
        println "The project's name    : ${project.name}"
        println "The project's version : ${project.version}"
    }
}
